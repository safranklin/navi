use ratatui::Frame;
use ratatui::layout::{Constraint, Flex, Layout, Rect};
use ratatui::style::Color;
use ratatui::widgets::canvas::{Canvas, Shape};

// Embedded ASCII frames (generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/landing_frames.rs"));

/// The Logo component responsible for rendering the Navi animation.
pub struct Logo;

impl Logo {
    pub fn required_height() -> u16 {
        let logo_rows = (LOGO_HEIGHT / 4.0).ceil() as u16;
        logo_rows + 2 // Padding
    }

    pub fn render(frame: &mut Frame, area: Rect, frame_index: usize) {
        let frame_count = LOGO_FRAMES.len();
        if frame_count == 0 {
            return;
        }

        // Slow down animation (divide by 3)
        let slow_frame_index = frame_index / 3;
        let current_frame_idx = slow_frame_index % frame_count;
        let points = LOGO_FRAMES[current_frame_idx];

        // Canvas Height in ROWS = Dot Height / 4.
        let logo_rows = (LOGO_HEIGHT / 4.0).ceil() as u16;
        let canvas_height = logo_rows + 2; // Add a bit of breathing room/padding

        // Canvas Width in COLS = Dot Width / 2.
        let logo_cols = (LOGO_WIDTH / 2.0).ceil() as u16;
        let canvas_width = logo_cols + 2;

        // Vertical Layout to center it within the given area (if larger)
        // Or we just consume the area?
        // Let's assume the caller handles general positioning, but we enforce sizing.
        // Actually, the previous logic in LandingPage handled vertical centering of the *group* (fairy + text).
        // Here, we just want to render the Fairy in the provided area, but ensuring we don't stretch.

        // We really want to render exactly at our desired size, centered in `area`.

        let vertical_layout = Layout::vertical([Constraint::Length(canvas_height)])
            .flex(Flex::Center)
            .split(area);

        let horizontal_layout = Layout::horizontal([Constraint::Length(canvas_width)])
            .flex(Flex::Center)
            .split(vertical_layout[0]);

        // --- Render Canvas (Fairy) ---
        let canvas_max_x = (canvas_width as f64) * 2.0;
        let canvas_max_y = (canvas_height as f64) * 4.0;

        // Manual Nudge: The visual center of the body seems to be about 4-5 dots to the right
        // of where it's currently rendering.
        // Positive Nudge -> Moves Fairy RIGHT.
        // Negative Nudge -> Moves Fairy LEFT.
        const MANUAL_NUDGE: f64 = -1.0;

        let offset_x = (canvas_max_x / 2.0) - LOGO_COM_X + MANUAL_NUDGE;
        let offset_y = (canvas_max_y - LOGO_HEIGHT) / 2.0;

        let canvas = Canvas::default()
            .x_bounds([0.0, canvas_max_x])
            .y_bounds([0.0, canvas_max_y])
            .paint(move |ctx| {
                ctx.draw(&Dots {
                    points,
                    color: Color::Blue,
                    offset_x,
                    offset_y,
                    canvas_max_y,
                });
            });

        frame.render_widget(canvas, horizontal_layout[0]);
    }
}

// Helper Shape for drawing dots
struct Dots<'a> {
    points: &'a [(f64, f64)],
    color: Color,
    offset_x: f64,
    offset_y: f64,
    canvas_max_y: f64,
}

impl<'a> Shape for Dots<'a> {
    fn draw(&self, painter: &mut ratatui::widgets::canvas::Painter) {
        for (x, y) in self.points {
            let draw_x = x + self.offset_x;

            // Image Y=0 is TOP. Canvas Y=0 is BOTTOM.
            // We want (x, 0) to be drawn at (x, canvas_max_y - offset_y).
            // We want (x, h) to be drawn at (x, canvas_max_y - offset_y - h).

            let draw_y = (self.canvas_max_y - self.offset_y) - y;

            if let Some((rx, ry)) = painter.get_point(draw_x, draw_y) {
                painter.paint(rx, ry, self.color);
            }
        }
    }
}
